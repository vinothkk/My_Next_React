import React, { useMemo, useState, useCallback } from 'react';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import MaterialReactTable from 'material-react-table';
import dayjs from 'dayjs';

const DynamicDateRangeFilter = () => {
  const [data, setData] = useState([
    { id: 1, date: '2023-01-01' },
    { id: 2, date: '2023-06-15' },
    { id: 3, date: '2024-02-20' },
  ]);

  const columns = useMemo(() => [
    {
      accessorKey: 'date',
      header: 'Date',
      filterVariant: 'date-range',
      
      // Custom filter function for date range
      filterFn: (row, columnId, filterValues) => {
        const [min, max] = filterValues;
        
        // If no filter values are set, show all rows
        if (!min && !max) return true;
        
        const rowDate = dayjs(row.original[columnId]);
        
        // Check if row date is within the selected range
        const isAfterMin = !min || rowDate.isAfter(dayjs(min).startOf('day'));
        const isBeforeMax = !max || rowDate.isBefore(dayjs(max).endOf('day'));
        
        return isAfterMin && isBeforeMax;
      },
      
      // Custom date range picker configuration
      muiFilterDatePickerProps: {
        slots: {
          // Custom date picker component to implement advanced validation
          textField: (props) => {
            const { inputProps, InputProps, ...rest } = props;
            const isStartDatePicker = inputProps?.['data-testid']?.includes('start');
            
            return (
              <DatePicker
                {...rest}
                inputProps={inputProps}
                InputProps={InputProps}
                // Dynamic min and max date constraints
                minDate={isStartDatePicker 
                  ? null  // No minimum for start date picker initially
                  : props.value?.[0] || null  // Max date picker can't be before start date
                }
                maxDate={!isStartDatePicker 
                  ? null  // No maximum for end date picker initially
                  : props.value?.[1] || null  // Min date picker can't be after end date
                }
                // Disable dates based on the other picker's selection
                shouldDisableDate={(day) => {
                  const [startDate, endDate] = props.value || [];
                  
                  if (isStartDatePicker && endDate) {
                    // For start date picker, disable dates after end date
                    return day.isAfter(endDate);
                  }
                  
                  if (!isStartDatePicker && startDate) {
                    // For end date picker, disable dates before start date
                    return day.isBefore(startDate);
                  }
                  
                  return false;
                }}
              />
            );
          }
        }
      }
    }
  ], []);

  return (
    <LocalizationProvider dateAdapter={AdapterDayjs}>
      <MaterialReactTable
        columns={columns}
        data={data}
        enableColumnFilters
        enableFilters
      />
    </LocalizationProvider>
  );
};

export default DynamicDateRangeFilter;
------------------------------Cloudi-3--------------------------------------
import React, { useMemo, useState, useCallback } from 'react';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import MaterialReactTable from 'material-react-table';
import dayjs from 'dayjs';

const DynamicDateRangeFilter = () => {
  const [data, setData] = useState([
    { id: 1, date: '2023-01-01' },
    { id: 2, date: '2023-06-15' },
    { id: 3, date: '2024-02-20' },
  ]);

  const columns = useMemo(() => [
    {
      accessorKey: 'date',
      header: 'Date',
      filterVariant: 'date-range',
      
      // Custom filter function to handle dynamic range validation
      filterFn: (row, columnId, filterValues) => {
        const [min, max] = filterValues;
        
        // If no filter values are set, show all rows
        if (!min && !max) return true;
        
        const rowDate = dayjs(row.original[columnId]);
        
        // Check if row date is within the selected range
        const isAfterMin = !min || rowDate.isAfter(dayjs(min).startOf('day'));
        const isBeforeMax = !max || rowDate.isBefore(dayjs(max).endOf('day'));
        
        return isAfterMin && isBeforeMax;
      },
      
      // Modify column definition to include custom props
      muiFilterDatePickerProps: {
        // Add props that don't rely on undefined context
        minDate: null,
        maxDate: null,
        
        // Remove context-dependent methods
        // Instead, handle date constraints in the table configuration
      }
    }
  ], []);

  return (
    <LocalizationProvider dateAdapter={AdapterDayjs}>
      <MaterialReactTable
        columns={columns}
        data={data}
        enableColumnFilters
        enableFilters
        
        // Move dynamic date range logic to table-level configuration
        onColumnFilterChange={(updatedColumnFilters) => {
          // Find the date column filter
          const dateFilter = updatedColumnFilters.find(
            filter => filter.id === 'date'
          );

          // If date filter exists, perform custom validation
          if (dateFilter && dateFilter.value) {
            const [minDate, maxDate] = dateFilter.value;
            
            // Custom validation logic
            if (minDate && maxDate) {
              const parsedMin = dayjs(minDate);
              const parsedMax = dayjs(maxDate);
              
              // Ensure min date is not after max date
              if (parsedMin.isAfter(parsedMax)) {
                // Optionally, you can show an error or reset the filter
                console.warn('Minimum date cannot be after maximum date');
                // You might want to reset the filter or show a toast/notification
              }
            }
          }
        }}
        
        // Optional: Custom date range filter props
        muiFilterDatePickerProps={{
          // Global date range constraints if needed
          minDate: dayjs('2023-01-01'),
          maxDate: dayjs('2024-12-31'),
        }}
      />
    </LocalizationProvider>
  );
};

export default DynamicDateRangeFilter;
-------------------------above is second----------------------------


import React, { useMemo, useState } from 'react';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import MaterialReactTable from 'material-react-table';
import dayjs from 'dayjs';

const DynamicDateRangeFilter = () => {
  const [data, setData] = useState([
    { id: 1, date: '2023-01-01' },
    { id: 2, date: '2023-06-15' },
    { id: 3, date: '2024-02-20' },
  ]);

  const columns = useMemo(() => [
    {
      accessorKey: 'date',
      header: 'Date',
      filterVariant: 'date-range',
      
      // Custom filter function to handle dynamic range validation
      filterFn: (row, columnId, filterValues) => {
        const [min, max] = filterValues;
        
        // If no filter values are set, show all rows
        if (!min && !max) return true;
        
        const rowDate = dayjs(row.original[columnId]);
        
        // Check if row date is within the selected range
        const isAfterMin = !min || rowDate.isAfter(dayjs(min).startOf('day'));
        const isBeforeMax = !max || rowDate.isBefore(dayjs(max).endOf('day'));
        
        return isAfterMin && isBeforeMax;
      },
      
      // Custom date picker props for dynamic validation
      muiFilterDatePickerProps: {
        // Dynamic min and max date logic
        minDate: null,
        maxDate: null,
        
        // Custom onChange handler to enforce date range rules
        onChange: (value, context) => {
          const { setFilterValue, filterValues } = context;
          const [currentMin, currentMax] = filterValues;
          
          if (context.type === 'start') {
            // If setting the start date, update min date
            setFilterValue([value, currentMax]);
          } else if (context.type === 'end') {
            // If setting the end date, update max date
            setFilterValue([currentMin, value]);
          }
        },
        
        // Custom validation function
        shouldDisableDate: (day, context) => {
          const [currentMin, currentMax] = context.filterValues;
          
          if (context.type === 'start' && currentMax) {
            // Disable dates after the current max when setting min
            return day.isAfter(currentMax);
          }
          
          if (context.type === 'end' && currentMin) {
            // Disable dates before the current min when setting max
            return day.isBefore(currentMin);
          }
          
          return false;
        }
      }
    }
  ], []);

  return (
    <LocalizationProvider dateAdapter={AdapterDayjs}>
      <MaterialReactTable
        columns={columns}
        data={data}
        enableColumnFilters
        enableFilters
      />
    </LocalizationProvider>
  );
};

export default DynamicDateRangeFilter;
-------------------------------------------------------------------------------------

import { useState, useEffect } from "react";

const useFilteredData = (data, columnFilters) => {
    const [filteredData, setFilteredData] = useState([]);
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    // Function to filter data based on column filters
    const filterData = (data, columnFilters) => {
        let filtered = [...data];

        for (const filter of columnFilters) {
            const { id, value } = filter;

            filtered = filtered.filter((row) => {
                if (id === "Close Date") return row;

                if (id === "amount") {
                    return parseInt(row[id] ?? 0) >= (value ?? 0);
                }

                if (id === "probability") {
                    return parseInt(row[id] ?? 0) >= (value[0] ?? 0) &&
                        parseInt(row[id] ?? 0) <= (value[1] ?? 100);
                }

                if (row[id] != null && id !== "probability" && id !== "amount" && id !== "Close Date") {
                    return row[id]?.toLowerCase().includes(value?.toLowerCase());
                }
            });
        }
        return filtered;
    };

    // Function to filter data by date
    const filterByDate = (data, fromDate, toDate) => {
        return data.filter((item) => {
            const currentData = item.closeDate;
            return (!fromDate || currentData >= fromDate) && (!toDate || currentData <= toDate);
        });
    };

    // Function to calculate metrics
    const calculateMetrics = (filtered) => {
        const totalOpportunities = filtered.length ?? 0;
        const totalProjectedTotalRevenue = filtered.reduce(
            (sum, revenue) => sum + parseInt(revenue?.totalProjectedAnnualizedRevenue ?? 0), 0
        );
        const totalProjectedWeightedRevenue = filtered.reduce(
            (sum, revenue) => sum + parseInt(revenue?.projectedWeightedRevenue ?? 0), 0
        );
        const totalProjectedAVGProbability = filtered.reduce(
            (sum, revenue) => sum + parseInt(revenue?.probability ?? 0), 0
        );

        return {
            totalOpportunities,
            totalProjectedTotalRevenue,
            totalProjectedWeightedRevenue,
            averageProbability: totalOpportunities > 0 ? (totalProjectedAVGProbability / totalOpportunities).toFixed(2) : 0
        };
    };

    useEffect(() => {
        let filtered = filterData(data, columnFilters);

        const extractedDates = columnFilters.find(item => item.id === "Close Date")?.value || [];
        const fromDate = extractedDates[0]?.split("T")[0] ?? null;
        const toDate = extractedDates[1]?.split("T")[0] ?? null;

        if (fromDate || toDate) {
            filtered = filterByDate(filtered, fromDate, toDate);
        }

        setFilteredData(filtered);
        setMetrics(calculateMetrics(filtered));
    }, [data, columnFilters]);

    return { filteredData, ...metrics };
};

export default useFilteredData;



-----------------------------------------
import React, { useState } from "react";
import useFilteredData from "../hooks/useFilteredData";

const Pipeline = ({ data }) => {
    const [columnFilters, setColumnFilters] = useState([
        { id: "amount", value: 5000 },
        { id: "probability", value: [30, 80] },
        { id: "Close Date", value: ["2024-03-01T00:00:00Z", "2024-03-31T23:59:59Z"] },
    ]);

    const { filteredData, totalRevenue, totalWeightedRevenue, averageProbability, totalOpportunities } = useFilteredData(data, columnFilters);

    return (
        <div>
            <h2>Filtered Data</h2>
            <p>Total Opportunities: {totalOpportunities}</p>
            <p>Total Revenue: ${totalRevenue}</p>
            <p>Total Weighted Revenue: ${totalWeightedRevenue}</p>
            <p>Average Probability: {averageProbability}%</p>
            <ul>
                {filteredData.map((item, index) => (
                    <li key={index}>{item.name} - ${item.amount}</li>
                ))}
            </ul>
        </div>
    );
};

export default Expo
===========================
import { useState, useMemo } from "react";

const useFilteredData = (data, columnFilters) => {
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    const filteredData = useMemo(() => {
        if (!Array.isArray(data) || data.length === 0) return [];

        let filtered = new Array(data.length); // Preallocate array
        let count = 0;

        let totalRevenue = 0,
            totalWeightedRevenue = 0,
            totalProbability = 0,
            totalOpportunities = 0;

        for (let i = 0; i < data.length; i++) {
            let row = data[i];
            let isValid = true;

            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (typeof rowValue === "number") {
                    rowValue = rowValue.toString(); // Convert numbers to string for comparison
                }

                // Dynamic Filtering Based on Type
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    // Handle range filters (e.g., probability: [30, 80])
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                filtered[count++] = row; // Store valid rows efficiently
                totalRevenue += parseInt(row?.totalProjectedAnnualizedRevenue ?? 0);
                totalWeightedRevenue += parseInt(row?.projectedWeightedRevenue ?? 0);
                totalProbability += parseInt(row?.probability ?? 0);
                totalOpportunities++;
            }
        }

        setMetrics({
            totalOpportunities,
            totalRevenue,
            totalWeightedRevenue,
            averageProbability: totalOpportunities > 0 ? (totalProbability / totalOpportunities).toFixed(2) : 0,
        });

        return filtered.slice(0, count); // Trim unused space
    }, [data, columnFilters]);

    return { filteredData, ...metrics };
};

export default useFilteredData;


import React, { useState } from "react";
import useFilteredData from "../hooks/useFilteredData";

const Pipeline = ({ data }) => {
    const [columnFilters, setColumnFilters] = useState([
        { id: "amount", value: 5000 },
        { id: "probability", value: [30, 80] },
        { id: "name", value: "John" }, // Dynamic field filter
    ]);

    const { filteredData, totalRevenue, totalWeightedRevenue, averageProbability, totalOpportunities } =
        useFilteredData(data, columnFilters);

    return (
        <div>
            <h2>Filtered Data</h2>
            <p>Total Opportunities: {totalOpportunities}</p>
            <p>Total Revenue: ${totalRevenue}</p>
            <p>Total Weighted Revenue: ${totalWeightedRevenue}</p>
            <p>Average Probability: {averageProbability}%</p>

            <ul>
                {filteredData.map((item, index) => (
                    <li key={index}>{item.name} - ${item.amount}</li>
                ))}
            </ul>
        </div>
    );
};

export default Pipeline;

=====================================
import { useState, useMemo, useEffect } from "react";

const useFilteredData = (data, columnFilters) => {
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    const filteredData = useMemo(() => {
        if (!Array.isArray(data) || data.length === 0) return [];

        let filtered = new Array(data.length); // Preallocate array
        let count = 0;

        let totalRevenue = 0,
            totalWeightedRevenue = 0,
            totalProbability = 0,
            totalOpportunities = 0;

        for (let i = 0; i < data.length; i++) {
            let row = data[i];
            let isValid = true;

            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (typeof rowValue === "number") {
                    rowValue = rowValue.toString(); // Convert numbers to string for comparison
                }

                // Dynamic Filtering Based on Type
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    // Handle range filters (e.g., probability: [30, 80])
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                filtered[count++] = row; // Store valid rows efficiently
                totalRevenue += parseInt(row?.totalProjectedAnnualizedRevenue ?? 0);
                totalWeightedRevenue += parseInt(row?.projectedWeightedRevenue ?? 0);
                totalProbability += parseInt(row?.probability ?? 0);
                totalOpportunities++;
            }
        }

        return { filtered: filtered.slice(0, count), metrics: { totalRevenue, totalWeightedRevenue, totalProbability, totalOpportunities } };
    }, [data, columnFilters]);

    // ✅ Use useEffect to update state after filtering
    useEffect(() => {
        const { totalRevenue, totalWeightedRevenue, totalProbability, totalOpportunities } = filteredData.metrics;
        setMetrics({
            totalRevenue,
            totalWeightedRevenue,
            totalOpportunities,
            averageProbability: totalOpportunities > 0 ? (totalProbability / totalOpportunities).toFixed(2) : 0,
        });
    }, [filteredData.metrics]);

    return { filteredData: filteredData.filtered, ...metrics };
};

export default useFilteredData;


==============================================================
import { useState, useMemo, useEffect } from "react";

const useFilteredData = (data, columnFilters) => {
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    const filteredData = useMemo(() => {
        if (!Array.isArray(data) || data.length === 0) return [];

        let filtered = new Array(data.length); // Preallocate array
        let count = 0;

        let totalRevenue = 0,
            totalWeightedRevenue = 0,
            totalProbability = 0,
            totalOpportunities = 0;

        for (let i = 0; i < data.length; i++) {
            let row = data[i];
            let isValid = true;

            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (typeof rowValue === "number") {
                    rowValue = rowValue.toString(); // Convert numbers to string for comparison
                }

                // Dynamic Filtering Based on Type
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    // Handle range filters (e.g., probability: [30, 80])
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                filtered[count++] = row; // Store valid rows efficiently
                totalRevenue += parseInt(row?.totalProjectedAnnualizedRevenue ?? 0);
                totalWeightedRevenue += parseInt(row?.projectedWeightedRevenue ?? 0);
                totalProbability += parseInt(row?.probability ?? 0);
                totalOpportunities++;
            }
        }

        return {
            filtered: filtered.slice(0, count),
            totalRevenue,
            totalWeightedRevenue,
            totalProbability,
            totalOpportunities,
        };
    }, [data, columnFilters]);

    // ✅ Use useEffect to update state after filtering
    useEffect(() => {
        if (!filteredData) return; // ✅ Prevent accessing undefined

        setMetrics({
            totalRevenue: filteredData.totalRevenue,
            totalWeightedRevenue: filteredData.totalWeightedRevenue,
            totalOpportunities: filteredData.totalOpportunities,
            averageProbability:
                filteredData.totalOpportunities > 0
                    ? (filteredData.totalProbability / filteredData.totalOpportunities).toFixed(2)
                    : 0,
        });
    }, [filteredData]);

    return { filteredData: filteredData.filtered, ...metrics };
};

export default useFilteredData;

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
import { useState, useMemo, useEffect } from "react";

const useFilteredData = (data = [], columnFilters = []) => {
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    const filteredData = useMemo(() => {
        if (!Array.isArray(data) || data.length === 0) return { filtered: [], totalRevenue: 0, totalWeightedRevenue: 0, totalProbability: 0, totalOpportunities: 0 };
        if (!Array.isArray(columnFilters)) return { filtered: [], totalRevenue: 0, totalWeightedRevenue: 0, totalProbability: 0, totalOpportunities: 0 };

        let filtered = new Array(data.length); // Preallocate array
        let count = 0;

        let totalRevenue = 0,
            totalWeightedRevenue = 0,
            totalProbability = 0,
            totalOpportunities = 0;

        for (let i = 0; i < data.length; i++) {
            let row = data[i];
            if (!row) continue; // Safety check to prevent accessing null/undefined rows

            let isValid = true;

            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (typeof rowValue === "number") {
                    rowValue = rowValue.toString(); // Convert numbers to string for comparison
                }

                // Dynamic Filtering Based on Type
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    // Handle range filters (e.g., probability: [30, 80])
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                filtered[count++] = row; // Store valid rows efficiently
                totalRevenue += parseInt(row?.totalProjectedAnnualizedRevenue ?? 0);
                totalWeightedRevenue += parseInt(row?.projectedWeightedRevenue ?? 0);
                totalProbability += parseInt(row?.probability ?? 0);
                totalOpportunities++;
            }
        }

        return {
            filtered: filtered.slice(0, count),
            totalRevenue,
            totalWeightedRevenue,
            totalProbability,
            totalOpportunities,
        };
    }, [data, columnFilters]);

    // ✅ Use useEffect to update state safely
    useEffect(() => {
        if (!filteredData) return; // ✅ Prevent accessing undefined

        setMetrics({
            totalRevenue: filteredData.totalRevenue,
            totalWeightedRevenue: filteredData.totalWeightedRevenue,
            totalOpportunities: filteredData.totalOpportunities,
            averageProbability:
                filteredData.totalOpportunities > 0
                    ? (filteredData.totalProbability / filteredData.totalOpportunities).toFixed(2)
                    : 0,
        });
    }, [filteredData]);

    return { filteredData: filteredData.filtered, ...metrics };
};

export default useFilteredData;

===================Date=================================
            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (id === "Close Date" && Array.isArray(value) && value.length === 2) {
                    // Extract start and end dates
+                   const fromDate = value[0] ? new Date(value[0]) : null;
+                   const toDate = value[1] ? new Date(value[1]) : null;
+                   const rowDate = rowValue ? new Date(rowValue) : null;

+                   if (!rowDate || isNaN(rowDate)) {
+                       isValid = false; // Skip invalid date rows
+                       break;
+                   }

+                   if (fromDate && !isNaN(fromDate) && rowDate < fromDate) {
+                       isValid = false;
+                       break;
+                   }

+                   if (toDate && !isNaN(toDate) && rowDate > toDate) {
+                       isValid = false;
+                       break;
+                   }
                    continue; // Skip remaining checks since date filtering is done
                }

                // Handle other filters normally
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

==================Final================
import { useState, useMemo, useEffect } from "react";

const useFilteredData = (data = [], columnFilters = []) => {
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    const filteredData = useMemo(() => {
        if (!Array.isArray(data) || data.length === 0) return { filtered: [], totalRevenue: 0, totalWeightedRevenue: 0, totalProbability: 0, totalOpportunities: 0 };
        if (!Array.isArray(columnFilters)) return { filtered: [], totalRevenue: 0, totalWeightedRevenue: 0, totalProbability: 0, totalOpportunities: 0 };

        let filtered = new Array(data.length); // Preallocate array
        let count = 0;

        let totalRevenue = 0,
            totalWeightedRevenue = 0,
            totalProbability = 0,
            totalOpportunities = 0;

        // Extract Close Date filter
        const tempDate1 = JSON.stringify(columnFilters);
        const tempDate2 = JSON.parse(tempDate1);
        const extractedDates = tempDate2.find(item => item.id === "Close Date")?.value || [];

        const fromDate = extractedDates[0] ? extractedDates[0].split("T")[0] : null;
        const toDate = extractedDates[1] ? extractedDates[1].split("T")[0] : null;

        for (let i = 0; i < data.length; i++) {
            let row = data[i];
            if (!row) continue; // Safety check to prevent accessing null/undefined rows

            let isValid = true;

            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (id === "Close Date") {
                    const currentDate = row?.closeDate ? row.closeDate.split("T")[0] : null;

                    if ((!fromDate || currentDate >= fromDate) && (!toDate || currentDate <= toDate)) {
                        continue;
                    } else {
                        isValid = false;
                        break;
                    }
                }

                if (typeof rowValue === "number") {
                    rowValue = rowValue.toString(); // Convert numbers to string for comparison
                }

                // Dynamic Filtering Based on Type
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    // Handle range filters (e.g., probability: [30, 80])
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                filtered[count++] = row; // Store valid rows efficiently
                totalRevenue += parseInt(row?.totalProjectedAnnualizedRevenue ?? 0);
                totalWeightedRevenue += parseInt(row?.projectedWeightedRevenue ?? 0);
                totalProbability += parseInt(row?.probability ?? 0);
                totalOpportunities++;
            }
        }

        return {
            filtered: filtered.slice(0, count),
            totalRevenue,
            totalWeightedRevenue,
            totalProbability,
            totalOpportunities,
        };
    }, [data, columnFilters]);

    // ✅ Use useEffect to update state safely
    useEffect(() => {
        if (!filteredData) return; // ✅ Prevent accessing undefined

        setMetrics({
            totalRevenue: filteredData.totalRevenue,
            totalWeightedRevenue: filteredData.totalWeightedRevenue,
            totalOpportunities: filteredData.totalOpportunities,
            averageProbability:
                filteredData.totalOpportunities > 0
                    ? (filteredData.totalProbability / filteredData.totalOpportunities).toFixed(2)
                    : 0,
        });
    }, [filteredData]);

    return { filteredData: filteredData.filtered, ...metrics };
};

export default useFilteredData;



