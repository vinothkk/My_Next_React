import { useState, useEffect } from "react";

const useFilteredData = (data, columnFilters) => {
    const [filteredData, setFilteredData] = useState([]);
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    // Function to filter data based on column filters
    const filterData = (data, columnFilters) => {
        let filtered = [...data];

        for (const filter of columnFilters) {
            const { id, value } = filter;

            filtered = filtered.filter((row) => {
                if (id === "Close Date") return row;

                if (id === "amount") {
                    return parseInt(row[id] ?? 0) >= (value ?? 0);
                }

                if (id === "probability") {
                    return parseInt(row[id] ?? 0) >= (value[0] ?? 0) &&
                        parseInt(row[id] ?? 0) <= (value[1] ?? 100);
                }

                if (row[id] != null && id !== "probability" && id !== "amount" && id !== "Close Date") {
                    return row[id]?.toLowerCase().includes(value?.toLowerCase());
                }
            });
        }
        return filtered;
    };

    // Function to filter data by date
    const filterByDate = (data, fromDate, toDate) => {
        return data.filter((item) => {
            const currentData = item.closeDate;
            return (!fromDate || currentData >= fromDate) && (!toDate || currentData <= toDate);
        });
    };

    // Function to calculate metrics
    const calculateMetrics = (filtered) => {
        const totalOpportunities = filtered.length ?? 0;
        const totalProjectedTotalRevenue = filtered.reduce(
            (sum, revenue) => sum + parseInt(revenue?.totalProjectedAnnualizedRevenue ?? 0), 0
        );
        const totalProjectedWeightedRevenue = filtered.reduce(
            (sum, revenue) => sum + parseInt(revenue?.projectedWeightedRevenue ?? 0), 0
        );
        const totalProjectedAVGProbability = filtered.reduce(
            (sum, revenue) => sum + parseInt(revenue?.probability ?? 0), 0
        );

        return {
            totalOpportunities,
            totalProjectedTotalRevenue,
            totalProjectedWeightedRevenue,
            averageProbability: totalOpportunities > 0 ? (totalProjectedAVGProbability / totalOpportunities).toFixed(2) : 0
        };
    };

    useEffect(() => {
        let filtered = filterData(data, columnFilters);

        const extractedDates = columnFilters.find(item => item.id === "Close Date")?.value || [];
        const fromDate = extractedDates[0]?.split("T")[0] ?? null;
        const toDate = extractedDates[1]?.split("T")[0] ?? null;

        if (fromDate || toDate) {
            filtered = filterByDate(filtered, fromDate, toDate);
        }

        setFilteredData(filtered);
        setMetrics(calculateMetrics(filtered));
    }, [data, columnFilters]);

    return { filteredData, ...metrics };
};

export default useFilteredData;



-----------------------------------------
import React, { useState } from "react";
import useFilteredData from "../hooks/useFilteredData";

const Pipeline = ({ data }) => {
    const [columnFilters, setColumnFilters] = useState([
        { id: "amount", value: 5000 },
        { id: "probability", value: [30, 80] },
        { id: "Close Date", value: ["2024-03-01T00:00:00Z", "2024-03-31T23:59:59Z"] },
    ]);

    const { filteredData, totalRevenue, totalWeightedRevenue, averageProbability, totalOpportunities } = useFilteredData(data, columnFilters);

    return (
        <div>
            <h2>Filtered Data</h2>
            <p>Total Opportunities: {totalOpportunities}</p>
            <p>Total Revenue: ${totalRevenue}</p>
            <p>Total Weighted Revenue: ${totalWeightedRevenue}</p>
            <p>Average Probability: {averageProbability}%</p>
            <ul>
                {filteredData.map((item, index) => (
                    <li key={index}>{item.name} - ${item.amount}</li>
                ))}
            </ul>
        </div>
    );
};

export default Expo
===========================
import { useState, useMemo } from "react";

const useFilteredData = (data, columnFilters) => {
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    const filteredData = useMemo(() => {
        if (!Array.isArray(data) || data.length === 0) return [];

        let filtered = new Array(data.length); // Preallocate array
        let count = 0;

        let totalRevenue = 0,
            totalWeightedRevenue = 0,
            totalProbability = 0,
            totalOpportunities = 0;

        for (let i = 0; i < data.length; i++) {
            let row = data[i];
            let isValid = true;

            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (typeof rowValue === "number") {
                    rowValue = rowValue.toString(); // Convert numbers to string for comparison
                }

                // Dynamic Filtering Based on Type
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    // Handle range filters (e.g., probability: [30, 80])
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                filtered[count++] = row; // Store valid rows efficiently
                totalRevenue += parseInt(row?.totalProjectedAnnualizedRevenue ?? 0);
                totalWeightedRevenue += parseInt(row?.projectedWeightedRevenue ?? 0);
                totalProbability += parseInt(row?.probability ?? 0);
                totalOpportunities++;
            }
        }

        setMetrics({
            totalOpportunities,
            totalRevenue,
            totalWeightedRevenue,
            averageProbability: totalOpportunities > 0 ? (totalProbability / totalOpportunities).toFixed(2) : 0,
        });

        return filtered.slice(0, count); // Trim unused space
    }, [data, columnFilters]);

    return { filteredData, ...metrics };
};

export default useFilteredData;


import React, { useState } from "react";
import useFilteredData from "../hooks/useFilteredData";

const Pipeline = ({ data }) => {
    const [columnFilters, setColumnFilters] = useState([
        { id: "amount", value: 5000 },
        { id: "probability", value: [30, 80] },
        { id: "name", value: "John" }, // Dynamic field filter
    ]);

    const { filteredData, totalRevenue, totalWeightedRevenue, averageProbability, totalOpportunities } =
        useFilteredData(data, columnFilters);

    return (
        <div>
            <h2>Filtered Data</h2>
            <p>Total Opportunities: {totalOpportunities}</p>
            <p>Total Revenue: ${totalRevenue}</p>
            <p>Total Weighted Revenue: ${totalWeightedRevenue}</p>
            <p>Average Probability: {averageProbability}%</p>

            <ul>
                {filteredData.map((item, index) => (
                    <li key={index}>{item.name} - ${item.amount}</li>
                ))}
            </ul>
        </div>
    );
};

export default Pipeline;

=====================================
import { useState, useMemo, useEffect } from "react";

const useFilteredData = (data, columnFilters) => {
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    const filteredData = useMemo(() => {
        if (!Array.isArray(data) || data.length === 0) return [];

        let filtered = new Array(data.length); // Preallocate array
        let count = 0;

        let totalRevenue = 0,
            totalWeightedRevenue = 0,
            totalProbability = 0,
            totalOpportunities = 0;

        for (let i = 0; i < data.length; i++) {
            let row = data[i];
            let isValid = true;

            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (typeof rowValue === "number") {
                    rowValue = rowValue.toString(); // Convert numbers to string for comparison
                }

                // Dynamic Filtering Based on Type
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    // Handle range filters (e.g., probability: [30, 80])
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                filtered[count++] = row; // Store valid rows efficiently
                totalRevenue += parseInt(row?.totalProjectedAnnualizedRevenue ?? 0);
                totalWeightedRevenue += parseInt(row?.projectedWeightedRevenue ?? 0);
                totalProbability += parseInt(row?.probability ?? 0);
                totalOpportunities++;
            }
        }

        return { filtered: filtered.slice(0, count), metrics: { totalRevenue, totalWeightedRevenue, totalProbability, totalOpportunities } };
    }, [data, columnFilters]);

    // ✅ Use useEffect to update state after filtering
    useEffect(() => {
        const { totalRevenue, totalWeightedRevenue, totalProbability, totalOpportunities } = filteredData.metrics;
        setMetrics({
            totalRevenue,
            totalWeightedRevenue,
            totalOpportunities,
            averageProbability: totalOpportunities > 0 ? (totalProbability / totalOpportunities).toFixed(2) : 0,
        });
    }, [filteredData.metrics]);

    return { filteredData: filteredData.filtered, ...metrics };
};

export default useFilteredData;


==============================================================
import { useState, useMemo, useEffect } from "react";

const useFilteredData = (data, columnFilters) => {
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    const filteredData = useMemo(() => {
        if (!Array.isArray(data) || data.length === 0) return [];

        let filtered = new Array(data.length); // Preallocate array
        let count = 0;

        let totalRevenue = 0,
            totalWeightedRevenue = 0,
            totalProbability = 0,
            totalOpportunities = 0;

        for (let i = 0; i < data.length; i++) {
            let row = data[i];
            let isValid = true;

            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (typeof rowValue === "number") {
                    rowValue = rowValue.toString(); // Convert numbers to string for comparison
                }

                // Dynamic Filtering Based on Type
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    // Handle range filters (e.g., probability: [30, 80])
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                filtered[count++] = row; // Store valid rows efficiently
                totalRevenue += parseInt(row?.totalProjectedAnnualizedRevenue ?? 0);
                totalWeightedRevenue += parseInt(row?.projectedWeightedRevenue ?? 0);
                totalProbability += parseInt(row?.probability ?? 0);
                totalOpportunities++;
            }
        }

        return {
            filtered: filtered.slice(0, count),
            totalRevenue,
            totalWeightedRevenue,
            totalProbability,
            totalOpportunities,
        };
    }, [data, columnFilters]);

    // ✅ Use useEffect to update state after filtering
    useEffect(() => {
        if (!filteredData) return; // ✅ Prevent accessing undefined

        setMetrics({
            totalRevenue: filteredData.totalRevenue,
            totalWeightedRevenue: filteredData.totalWeightedRevenue,
            totalOpportunities: filteredData.totalOpportunities,
            averageProbability:
                filteredData.totalOpportunities > 0
                    ? (filteredData.totalProbability / filteredData.totalOpportunities).toFixed(2)
                    : 0,
        });
    }, [filteredData]);

    return { filteredData: filteredData.filtered, ...metrics };
};

export default useFilteredData;

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
import { useState, useMemo, useEffect } from "react";

const useFilteredData = (data = [], columnFilters = []) => {
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    const filteredData = useMemo(() => {
        if (!Array.isArray(data) || data.length === 0) return { filtered: [], totalRevenue: 0, totalWeightedRevenue: 0, totalProbability: 0, totalOpportunities: 0 };
        if (!Array.isArray(columnFilters)) return { filtered: [], totalRevenue: 0, totalWeightedRevenue: 0, totalProbability: 0, totalOpportunities: 0 };

        let filtered = new Array(data.length); // Preallocate array
        let count = 0;

        let totalRevenue = 0,
            totalWeightedRevenue = 0,
            totalProbability = 0,
            totalOpportunities = 0;

        for (let i = 0; i < data.length; i++) {
            let row = data[i];
            if (!row) continue; // Safety check to prevent accessing null/undefined rows

            let isValid = true;

            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (typeof rowValue === "number") {
                    rowValue = rowValue.toString(); // Convert numbers to string for comparison
                }

                // Dynamic Filtering Based on Type
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    // Handle range filters (e.g., probability: [30, 80])
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                filtered[count++] = row; // Store valid rows efficiently
                totalRevenue += parseInt(row?.totalProjectedAnnualizedRevenue ?? 0);
                totalWeightedRevenue += parseInt(row?.projectedWeightedRevenue ?? 0);
                totalProbability += parseInt(row?.probability ?? 0);
                totalOpportunities++;
            }
        }

        return {
            filtered: filtered.slice(0, count),
            totalRevenue,
            totalWeightedRevenue,
            totalProbability,
            totalOpportunities,
        };
    }, [data, columnFilters]);

    // ✅ Use useEffect to update state safely
    useEffect(() => {
        if (!filteredData) return; // ✅ Prevent accessing undefined

        setMetrics({
            totalRevenue: filteredData.totalRevenue,
            totalWeightedRevenue: filteredData.totalWeightedRevenue,
            totalOpportunities: filteredData.totalOpportunities,
            averageProbability:
                filteredData.totalOpportunities > 0
                    ? (filteredData.totalProbability / filteredData.totalOpportunities).toFixed(2)
                    : 0,
        });
    }, [filteredData]);

    return { filteredData: filteredData.filtered, ...metrics };
};

export default useFilteredData;

===================Date=================================
            for (const filter of columnFilters) {
                const { id, value } = filter;
                if (!id || value === undefined || value === null) continue; // Ignore invalid filters

                let rowValue = row?.[id] ?? ""; // Handle `null` or `undefined`

                if (id === "Close Date" && Array.isArray(value) && value.length === 2) {
                    // Extract start and end dates
+                   const fromDate = value[0] ? new Date(value[0]) : null;
+                   const toDate = value[1] ? new Date(value[1]) : null;
+                   const rowDate = rowValue ? new Date(rowValue) : null;

+                   if (!rowDate || isNaN(rowDate)) {
+                       isValid = false; // Skip invalid date rows
+                       break;
+                   }

+                   if (fromDate && !isNaN(fromDate) && rowDate < fromDate) {
+                       isValid = false;
+                       break;
+                   }

+                   if (toDate && !isNaN(toDate) && rowDate > toDate) {
+                       isValid = false;
+                       break;
+                   }
                    continue; // Skip remaining checks since date filtering is done
                }

                // Handle other filters normally
                if (typeof value === "string") {
                    if (!rowValue.toLowerCase().includes(value.toLowerCase())) {
                        isValid = false;
                        break;
                    }
                } else if (Array.isArray(value) && value.length === 2) {
                    const numValue = parseFloat(rowValue) || 0;
                    if (numValue < value[0] || numValue > value[1]) {
                        isValid = false;
                        break;
                    }
                } else if (typeof value === "number") {
                    if (parseFloat(rowValue) < value) {
                        isValid = false;
                        break;
                    }
                }
            }

==================Final================
import { useState, useEffect } from "react";

const useFilteredData = (data, columnFilters) => {
    const [filteredData, setFilteredData] = useState([]);
    const [metrics, setMetrics] = useState({
        totalRevenue: 0,
        totalWeightedRevenue: 0,
        averageProbability: 0,
        totalOpportunities: 0,
    });

    // Function to filter data based on column filters
    const filterData = (data, columnFilters) => {
        let filtered = [...data];

        for (const filter of columnFilters) {
            const { id, value } = filter;

            filtered = filtered.filter((row) => {
                if (id === "Close Date") return row;

                if (id === "amount") {
                    return parseInt(row[id] ?? 0) >= (value ?? 0);
                }

                if (id === "probability") {
                    return parseInt(row[id] ?? 0) >= (value[0] ?? 0) &&
                        parseInt(row[id] ?? 0) <= (value[1] ?? 100);
                }

                if (row[id] != null && id !== "probability" && id !== "amount" && id !== "Close Date") {
                    return row[id]?.toLowerCase().includes(value?.toLowerCase());
                }
            });
        }
        return filtered;
    };

    // Function to filter data by date
    const filterByDate = (data, fromDate, toDate) => {
        return data.filter((item) => {
            const currentData = item.closeDate;
            return (!fromDate || currentData >= fromDate) && (!toDate || currentData <= toDate);
        });
    };

    // Function to calculate metrics
    const calculateMetrics = (filtered) => {
        const totalOpportunities = filtered.length ?? 0;
        const totalProjectedTotalRevenue = filtered.reduce(
            (sum, revenue) => sum + parseInt(revenue?.totalProjectedAnnualizedRevenue ?? 0), 0
        );
        const totalProjectedWeightedRevenue = filtered.reduce(
            (sum, revenue) => sum + parseInt(revenue?.projectedWeightedRevenue ?? 0), 0
        );
        const totalProjectedAVGProbability = filtered.reduce(
            (sum, revenue) => sum + parseInt(revenue?.probability ?? 0), 0
        );

        return {
            totalOpportunities,
            totalProjectedTotalRevenue,
            totalProjectedWeightedRevenue,
            averageProbability: totalOpportunities > 0 ? (totalProjectedAVGProbability / totalOpportunities).toFixed(2) : 0
        };
    };

    useEffect(() => {
        let filtered = filterData(data, columnFilters);

        const extractedDates = columnFilters.find(item => item.id === "Close Date")?.value || [];
        const fromDate = extractedDates[0]?.split("T")[0] ?? null;
        const toDate = extractedDates[1]?.split("T")[0] ?? null;

        if (fromDate || toDate) {
            filtered = filterByDate(filtered, fromDate, toDate);
        }

        setFilteredData(filtered);
        setMetrics(calculateMetrics(filtered));
    }, [data, columnFilters]);

    return { filteredData, ...metrics };
};

export default useFilteredData;


