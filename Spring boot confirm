Yes, you can use MySQL, PostgreSQL, and Databricks (usually via JDBC) drivers in a single Spring Boot application. This is called multi-datasource configuration, and it‚Äôs common in ETL, data integration, or microservice-style backend apps.

However, there are important considerations to avoid dependency and configuration issues.


---

‚úÖ Steps to Use MySQL, PostgreSQL, and Databricks in One Spring Boot App:

1. Add All Required Dependencies in pom.xml (Maven)

<!-- MySQL Driver -->
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- PostgreSQL Driver -->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- Databricks JDBC Driver (Simba JDBC Driver or similar) -->
<dependency>
    <groupId>com.databricks</groupId>
    <artifactId>spark-jdbc_2.12</artifactId>
    <version>REPLACE_WITH_ACTUAL</version>
</dependency>

You may need to manually download and install the Databricks JDBC driver JAR if it's not available on Maven Central.


---

2. Avoid Conflicts:

Spring Boot will auto-configure only one datasource by default. To avoid confusion:

Disable spring.datasource.* default configuration

Define each datasource manually (using @Primary for the main one)

Use separate JdbcTemplate or EntityManagerFactory for each DB



---

3. Configure Each Datasource Separately

Use separate configuration classes:

@Configuration
@ConfigurationProperties(prefix = "mysql.datasource")
public class MySQLConfig {
    @Bean
    @Primary
    public DataSource mysqlDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    public JdbcTemplate mysqlJdbcTemplate(@Qualifier("mysqlDataSource") DataSource ds) {
        return new JdbcTemplate(ds);
    }
}

@Configuration
@ConfigurationProperties(prefix = "postgres.datasource")
public class PostgresConfig {
    @Bean
    public DataSource postgresDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    public JdbcTemplate postgresJdbcTemplate(@Qualifier("postgresDataSource") DataSource ds) {
        return new JdbcTemplate(ds);
    }
}

@Configuration
@ConfigurationProperties(prefix = "databricks.datasource")
public class DatabricksConfig {
    @Bean
    public DataSource databricksDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    public JdbcTemplate databricksJdbcTemplate(@Qualifier("databricksDataSource") DataSource ds) {
        return new JdbcTemplate(ds);
    }
}


---

4. application.yml / application.properties

mysql:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: pass
    driver-class-name: com.mysql.cj.jdbc.Driver

postgres:
  datasource:
    url: jdbc:postgresql://localhost:5432/mydb
    username: postgres
    password: pass
    driver-class-name: org.postgresql.Driver

databricks:
  datasource:
    url: jdbc:spark://<databricks-host>:443/default;transportMode=http;ssl=1;httpPath=...
    username: token
    password: <your-access-token>
    driver-class-name: com.simba.spark.jdbc.Driver


---

üß† Notes:

Do not use Spring Boot auto-configured JPA if using multiple DBs with JPA unless you configure multiple EntityManagerFactory beans (which gets complicated).

If you're only reading/writing using JdbcTemplate, it's simpler and avoids JPA-related issues.

Databricks might require a custom driver or special URL formatting.

You must isolate transactions if using different databases for atomic operations.



---

‚úÖ Summary

Aspect	Support?	Notes

Multiple DBs (MySQL, PG)	‚úÖ Yes	Use separate beans
Databricks JDBC	‚úÖ Yes	May require manual driver
Auto-configuration issue	‚ö†Ô∏è Yes	Avoid Spring Boot's default spring.datasource.*
Conflict in drivers	‚ùå No	Not if you configure carefully
Recommended DB access	‚úÖ JdbcTemplate	Easier than JPA for multi-DB



---

If you'd like, I can give you a working example with JdbcTemplate using all 3 databases. Let me know.
Here‚Äôs a full working example of a Spring Boot application using JdbcTemplate to perform CRUD operations on MySQL, PostgreSQL, and Databricks (via JDBC).


---

‚úÖ Project Structure

springboot-multi-db-jdbctemplate/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ MySQLConfig.java
‚îÇ   ‚îú‚îÄ‚îÄ PostgresConfig.java
‚îÇ   ‚îî‚îÄ‚îÄ DatabricksConfig.java
‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îú‚îÄ‚îÄ MySQLUserRepository.java
‚îÇ   ‚îú‚îÄ‚îÄ PostgresUserRepository.java
‚îÇ   ‚îî‚îÄ‚îÄ DatabricksUserRepository.java
‚îú‚îÄ‚îÄ controller/
‚îÇ   ‚îî‚îÄ‚îÄ UserController.java
‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îî‚îÄ‚îÄ User.java
‚îú‚îÄ‚îÄ application.yml
‚îî‚îÄ‚îÄ SpringbootMultiDbApplication.java


---

‚úÖ 1. Model: User.java

package com.example.model;

public class User {
    private int id;
    private String name;
    private String email;

    // Getters and Setters
}


---

‚úÖ 2. Configuration Classes

‚û§ MySQLConfig.java

@Configuration
@ConfigurationProperties(prefix = "mysql.datasource")
public class MySQLConfig {

    @Bean(name = "mysqlDataSource")
    @Primary
    public DataSource mysqlDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = "mysqlJdbcTemplate")
    public JdbcTemplate mysqlJdbcTemplate(@Qualifier("mysqlDataSource") DataSource ds) {
        return new JdbcTemplate(ds);
    }
}

‚û§ PostgresConfig.java

@Configuration
@ConfigurationProperties(prefix = "postgres.datasource")
public class PostgresConfig {

    @Bean(name = "postgresDataSource")
    public DataSource postgresDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = "postgresJdbcTemplate")
    public JdbcTemplate postgresJdbcTemplate(@Qualifier("postgresDataSource") DataSource ds) {
        return new JdbcTemplate(ds);
    }
}

‚û§ DatabricksConfig.java

@Configuration
@ConfigurationProperties(prefix = "databricks.datasource")
public class DatabricksConfig {

    @Bean(name = "databricksDataSource")
    public DataSource databricksDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = "databricksJdbcTemplate")
    public JdbcTemplate databricksJdbcTemplate(@Qualifier("databricksDataSource") DataSource ds) {
        return new JdbcTemplate(ds);
    }
}


---

‚úÖ 3. Repository Classes

‚û§ MySQLUserRepository.java

@Repository
public class MySQLUserRepository {
    @Autowired
    @Qualifier("mysqlJdbcTemplate")
    private JdbcTemplate jdbcTemplate;

    public void save(User user) {
        jdbcTemplate.update("INSERT INTO users (id, name, email) VALUES (?, ?, ?)",
                user.getId(), user.getName(), user.getEmail());
    }

    public List<User> findAll() {
        return jdbcTemplate.query("SELECT * FROM users", userRowMapper());
    }

    private RowMapper<User> userRowMapper() {
        return (rs, rowNum) -> {
            User u = new User();
            u.setId(rs.getInt("id"));
            u.setName(rs.getString("name"));
            u.setEmail(rs.getString("email"));
            return u;
        };
    }
}

> Repeat similar for PostgresUserRepository and DatabricksUserRepository, just change the @Qualifier and bean injection accordingly.




---

‚úÖ 4. Controller Example

@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private MySQLUserRepository mysqlRepo;

    @Autowired
    private PostgresUserRepository postgresRepo;

    @Autowired
    private DatabricksUserRepository databricksRepo;

    @PostMapping("/mysql")
    public ResponseEntity<String> saveToMySQL(@RequestBody User user) {
        mysqlRepo.save(user);
        return ResponseEntity.ok("Saved to MySQL");
    }

    @PostMapping("/postgres")
    public ResponseEntity<String> saveToPostgres(@RequestBody User user) {
        postgresRepo.save(user);
        return ResponseEntity.ok("Saved to PostgreSQL");
    }

    @PostMapping("/databricks")
    public ResponseEntity<String> saveToDatabricks(@RequestBody User user) {
        databricksRepo.save(user);
        return ResponseEntity.ok("Saved to Databricks");
    }

    @GetMapping("/mysql")
    public List<User> getAllMySQL() {
        return mysqlRepo.findAll();
    }

    @GetMapping("/postgres")
    public List<User> getAllPostgres() {
        return postgresRepo.findAll();
    }

    @GetMapping("/databricks")
    public List<User> getAllDatabricks() {
        return databricksRepo.findAll();
    }
}


---

‚úÖ 5. application.yml

mysql:
  datasource:
    url: jdbc:mysql://localhost:3306/testdb
    username: root
    password: pass
    driver-class-name: com.mysql.cj.jdbc.Driver

postgres:
  datasource:
    url: jdbc:postgresql://localhost:5432/testdb
    username: postgres
    password: pass
    driver-class-name: org.postgresql.Driver

databricks:
  datasource:
    url: jdbc:spark://<host>:443/default;transportMode=http;ssl=1;httpPath=<path>
    username: token
    password: <access-token>
    driver-class-name: com.simba.spark.jdbc.Driver


---

‚úÖ 6. Table DDL Example

CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(100)
);


---

‚úÖ Dependencies in pom.xml

<!-- MySQL -->
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- PostgreSQL -->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- Databricks JDBC -->
<!-- This may require manual addition to local repo -->
<dependency>
    <groupId>com.simba.spark</groupId>
    <artifactId>spark-jdbc</artifactId>
    <version>REPLACE_WITH_ACTUAL</version>
</dependency>


---

üö® Notes

Databricks JDBC driver (Simba) may not be publicly available ‚Äî download and install manually if needed.

Each DB operation is independent; transactions are not shared across DBs.

Spring Boot dev tools or JPA are not used here to keep the configuration simple and JDBC-focused.



---

Would you like a working GitHub repo or ZIP file with this structure?



