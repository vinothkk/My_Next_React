const processNestedData = (items, level = 0, parentIndex = null) => {
  if (!items || !Array.isArray(items)) return [];

  return items
    .map((item, index) => {
      let matchesCurrentItem = false;
      const newItem = { ...item }; // Create shallow copy to avoid mutation

      // Highlight and check match
      searchFields.forEach(field => {
        if (newItem[field] && String(newItem[field]).toLowerCase().includes(termLower)) {
          matchesCurrentItem = true;
          newItem[field] = highlightText(String(newItem[field]), term);
        }
      });

      // Process subRows recursively (1st level)
      let filteredSubRows = [];
      if (Array.isArray(newItem.subRows)) {
        filteredSubRows = processNestedData(newItem.subRows, level + 1, index);
      }

      // Only include subRows if they matched
      if (filteredSubRows.length > 0) {
        newItem.subRows = filteredSubRows;
        trackExpanded(newItem.id, level, index);
      } else {
        delete newItem.subRows; // Remove subRows if empty
      }

      // Include row only if it or its children matched
      if (matchesCurrentItem || filteredSubRows.length > 0) {
        return newItem;
      }

      return null; // Otherwise, filter it out
    })
    .filter(Boolean); // Remove nulls
};
